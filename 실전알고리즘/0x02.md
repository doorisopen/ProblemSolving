# STL과 함수 인자

```
// 시간 복잡도 O(n)
bool cmp1 (vector<int> v1, vector<int> v2, int idx) {
    return v1[idx] > v2[idx];
}
// 시간 복잡도 O(1)
bool cmp2 (vector<int>& v1, vector<int>& v2, int idx) {
    return v1[idx] > v2[idx];
}
```

* cmp1에서 vector와 같은 stl은 원본을 그대로 가져오는 것이 아니라 구조체와 같이 복사하기 때문에 원본의 개수 N 만큼 복사하기 때문에 __시간복잡도가 O(N)이다.__
* cmp2에서 __참조자(&)__ 로 넘길 경우에 원본이 그대로 넘어가기 때문에 __O(1)이다.__


# 표준 입출력
* 공백을 포함한 문자열 입력받기

```
// 1. scanf의 옵션: \n(줄바꿈)이 나올때까지 입력받기
char a1[10];
scanf("%[]^\n", a1);
// 2. gets 함수: 보안상 이슈로 c++14 이상에서는 제거됨
char a2[10];
gets(a2);
puts(a2);
// 3. getline 함수: 타입이 c++ string 여야한다.
string s; 
getline(cin, s);
cout << s;
```

* cin, cout 사용할때 꼭 써야하는것

```
// 이걸 안해두면 입/출력 양이 많을 때 시간초과가 날 수 있다.
ios::sync_with_stdio(0), cin.tie(0)
```

보통 printf와 scanf등에서 쓰는 C stream과 cin/cout 등에서 쓰는 C++ stream은 분리가 되어있다.

printf와 cout을 번걸아하면 사용하는 상황을 생각해보자 

```
cout << "11111\n";
printf("22222\n")
cout << "33333\n";
```

사용자 입장에서는 C stream와 C++ stream 분리 되어있음은 상관없이 원하는 대로 출력이 된다. 이렇게 코드의 흐름과 실제 출력이 동일하기 위해서 기본적으로 프로그램에서는 C stream와 C++ stream를 동기화 시키고 있다. 만약 내가 C++ stream 만을 사용할 것이라면 굳이 2개의 Stream을 동기화 할 필요가 없다. 쓸때 없이 시간만 잡아먹으니까... 그렇기 때문에 C++ stream 만 쓸꺼면 동기화를 끊어버려서 프로그램 수행 시간에서 이득을 챙길 수 있고 명령어는 아래이다.

* __동기화를 끊는 명령어:__ ios::sync_with_stdio(0 or false)
  + 동기화를 끊었으면 절대 cout과 printf를 섞어쓰면 안된다.
  + 섞어쓰면 출력 결과가 꼬이게 된다.


__cin.tie(0)__ 는 버퍼의 개념을 이해해야한다. cin 명령을 수행하기 전에 cout 버퍼를 비우지 않도록 하는 코드이다.

* cin.tie(nullptr)

### endl 쓰지마라!!!!!
__endl은 개행문자(\ㅜ)를 출력하고 출력 버퍼를 비워라는 명령이다.__