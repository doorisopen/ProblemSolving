# 시간, 공간복잡도
## 시간복잡도(Time Complexity)
입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계

### 빅오표기법(Big-O Notaion)
주어진 식을 값이 가장 큰 대표항만 남겨서 나타내는 방법

* __O(N):__ 5N+3, 2N+10lgN, 10N
* __O(N^2):__ N^2 + 2N+5, 6N^2 + 20N + 10lgN
* __O(NlgN):__ NlgN + 30N + 10, 5lgN + 6
* __O(1):__ 5, 16, 36

> __O(1) < O(lgN) < O(N) < O(NlgN) < O(N^2) < O(2^N) < O(N!)__

|  <center>N의 크기</center> |  <center>허용 시간복잡도</center> |
|:--------:|:--------:|
| N <= 11 | O(N!) |
| N <= 25 | O(2^N) |
| N <= 100 | O(N^4) |
| N <= 500 | O(N^3) |
| N <= 3,000 | O(N^2lgN) |
| N <= 5,000 | O(N^2) |
| N <= 1,000,000 | O(NlgN) |
| N <= 10,000,000 | O(N) |
| 그 이상 | O(lgN), O(1) |

## 공간복잡도
입력의 크기와 문제를 해결하는데 필요한 공간의 상관관계

* 512MB = 1.2억개의 int(4byte)

# 정수, 실수 자료형
## 정수 자료형
* 하나의 char (1byte == 8bit)

* __unsigned char:__ __2^7__ 2^6 2^5 2^4 2^3 2^2 2^1 2^0
  + 자료형의 범위 = __0__ ~ 2^0+2^1...+2^7(=2^8 - 1 =__255__)
  + 0 0 0 0 1 0 0 1 = 9
  + 1 0 0 0 0 0 1 1 = 131
* __char:__ __-2^7__ 2^6 2^5 2^4 2^3 2^2 2^1 2^0
  + __2's complement__
  + 자료형의 범위 = -2^7(=__-128__) ~ 2^0+2^1...+2^6(2^7 - 1=__127__)
  + 0 0 0 0 1 0 0 1 = 9
  + 1 0 0 0 0 0 1 1 = -125

* __short__ (2 byte) 2^15-1(=32767)
* __int__ (4 byte) 2^31-1(=2.1*10^9)
* __long long__ (8 byte) 2^63-1(=9.2*10^18)
  + 80번째 피보나치 구할때는 이 자료형을 사용..

## 실수 자료형
* __float__ (4 byte)
  + 실수를 나타낼때 아래와 같이 나타낸다.
  + sign(1, 부호) exponent(8, 지수) fraction(23, 유효숫자)
* __double__ (8 byte)
  + sign(1) exponent(11) fraction(52)

* __3.75를 이진수로__
  + 2 + 1 + 0.5 + 0.25 = 2^1 + 2^0 + 2^-1 + 2^-2 = 11.11(2)


* __실수를 저장하는 방식:__ IEEE-754 format
* 실수의 저장/연산 과정에서 반드시 오차가 발생할 수 밖에 없다.
  + 0.1 + 0.1 + 0.1 == 0.3 -> != 틀리다!! 
  + 이유는 0.1은 이진수로 나타내면 무한소수여서 애초에 오차가 있는 채로 저장되기 때문이다.
  + float: 유효숫자 6자리(10^-6)까지 안전
  + double: 유효숫자 15자리(10^-15)까지 안전
    - __1-10^15 ~ 1+10^15 사이의 값__ 은 어느정도 보장된다는 말임
* double에 long long 범위의 정수를 함부로 담으면 안된다.
* 실수를 비교할 때는 등호를 사용하면 안된다.

## 연습 코드

```
#include <iostream>

using namespace std;

// O(n)
int func1(int num) {
	int sum = 0;
	for(int i = 1; i <= num; i++) {
		if(i % 3 == 0 || i % 5 == 0) {
			sum += i;
		}
	}
	return sum;
}
// O(N^2)
int func2(int *arr, int num) {
	int sum = 0;
	for(int i = 0; i < num; i++) {
		for(int j = i+1; j < num; j++) {
			if(arr[i] + arr[j] == 100) return 1;
		}
	}
	return 0; 
}
// O(n^1/2)
int func3(int N) {
	for(int i = 1; i*i <= N; i++) {
		if(i*i == N) return 1;
	}
	return 0;
}
// O(lgN)
int func4(int N) {
/* my sol */  
//	int max = 0;
//	for(int i = 1; i*i <= N; i*=2) {
//		if(i*i > max) { // 1 2 4
//			max = i*i;
//		}
//	}
//	return max;

	int val = 1;
	while(2*val <= N) val *= 2;
	return val;
}

int main(void) {

//	cout << func1(16) << endl;
//	cout << func1(34567) << endl;
//	cout << func1(27639) << endl;
	
//	int arr[3] = {1, 52, 48};
//	cout << func2(arr, 3) << endl;
//	int arr2[2] = {50, 42};
//	cout << func2(arr2, 2) << endl;
//	int arr3[4] = {4, 13, 63, 87};
//	cout << func2(arr3, 4) << endl;
	
//	cout << func3(9) << endl;
//	cout << func3(693953651) << endl;
//	cout << func3(756580036) << endl;
	
	cout << func4(5) << endl;
	cout << func4(97615282) << endl;
	cout << func4(1024) << endl;
	
	
	return 0;
}
```